# 异步工作流执行示例

## 示例1: 基本异步执行

```java
@RestController
@RequestMapping("/api/workflow")
public class WorkflowController {

    @Autowired
    private WorkflowExecuteManager workflowExecuteManager;

    @PostMapping("/execute/async")
    public ResponseEntity<String> executeWorkflowAsync(@RequestBody WorkflowRequest request) {
        try {
            // 创建工作流上下文
            WorkflowContext context = new WorkflowContext();
            context.setWorkspaceId(request.getWorkspaceId());
            context.setRequestId(request.getRequestId());
            context.setConversationId(request.getConversationId());
            context.setAppId(request.getAppId());
            
            // 设置用户输入参数
            context.getUserMap().putAll(request.getInputParams());
            
            // 异步执行工作流
            String taskId = workflowExecuteManager.asyncExecute(request.getConfig(), context);
            
            return ResponseEntity.ok(taskId);
        } catch (Exception e) {
            log.error("Failed to execute workflow asynchronously", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Failed to execute workflow: " + e.getMessage());
        }
    }
}
```

## 示例2: 带监控的异步执行

```java
@Service
public class WorkflowExecutionService {

    @Autowired
    private WorkflowExecuteManager workflowExecuteManager;
    
    @Autowired
    private RedisManager redisManager;

    public WorkflowExecutionResult executeWithMonitoring(WorkflowConfig config, WorkflowContext context) {
        // 异步执行工作流
        String taskId = workflowExecuteManager.asyncExecute(config, context);
        
        // 创建监控结果
        WorkflowExecutionResult result = new WorkflowExecutionResult();
        result.setTaskId(taskId);
        result.setStatus("EXECUTING");
        result.setStartTime(System.currentTimeMillis());
        
        // 启动监控线程
        startMonitoringThread(taskId, result);
        
        return result;
    }
    
    private void startMonitoringThread(String taskId, WorkflowExecutionResult result) {
        ThreadPoolUtils.DEFAULT_TASK_EXECUTOR.execute(() -> {
            try {
                while (true) {
                    // 获取最新的工作流上下文
                    WorkflowContext context = redisManager.get(
                        WORKFLOW_TASK_CONTEXT_PREFIX + result.getWorkspaceId() + "_" + taskId
                    );
                    
                    if (context == null) {
                        Thread.sleep(1000);
                        continue;
                    }
                    
                    // 更新执行状态
                    result.setStatus(context.getTaskStatus());
                    result.setNodeResults(new ArrayList<>(context.getNodeResultMap().values()));
                    
                    // 检查是否完成
                    if (NodeStatusEnum.SUCCESS.getCode().equals(context.getTaskStatus()) ||
                        NodeStatusEnum.FAIL.getCode().equals(context.getTaskStatus())) {
                        result.setEndTime(System.currentTimeMillis());
                        result.setTaskResult(context.getTaskResult());
                        result.setErrorInfo(context.getErrorInfo());
                        break;
                    }
                    
                    Thread.sleep(1000);
                }
            } catch (Exception e) {
                log.error("Error monitoring workflow execution", e);
                result.setStatus(NodeStatusEnum.FAIL.getCode());
                result.setErrorInfo(e.getMessage());
            }
        });
    }
}
```

## 示例3: 批量异步执行

```java
@Service
public class BatchWorkflowService {

    @Autowired
    private WorkflowExecuteManager workflowExecuteManager;

    public List<String> executeBatchWorkflows(List<WorkflowRequest> requests) {
        List<String> taskIds = new ArrayList<>();
        
        for (WorkflowRequest request : requests) {
            try {
                WorkflowContext context = createWorkflowContext(request);
                String taskId = workflowExecuteManager.asyncExecute(request.getConfig(), context);
                taskIds.add(taskId);
                
                log.info("Started async workflow execution: taskId={}, appId={}", 
                        taskId, request.getAppId());
            } catch (Exception e) {
                log.error("Failed to start async workflow execution for appId: {}", 
                        request.getAppId(), e);
                taskIds.add(null); // 标记失败
            }
        }
        
        return taskIds;
    }
    
    private WorkflowContext createWorkflowContext(WorkflowRequest request) {
        WorkflowContext context = new WorkflowContext();
        context.setWorkspaceId(request.getWorkspaceId());
        context.setRequestId(request.getRequestId());
        context.setConversationId(request.getConversationId());
        context.setAppId(request.getAppId());
        context.getUserMap().putAll(request.getInputParams());
        return context;
    }
}
```

## 示例4: 错误处理和重试

```java
@Service
public class RobustWorkflowService {

    @Autowired
    private WorkflowExecuteManager workflowExecuteManager;
    
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final long RETRY_DELAY_MS = 5000;

    public String executeWithRetry(WorkflowConfig config, WorkflowContext context) {
        int attempts = 0;
        Exception lastException = null;
        
        while (attempts < MAX_RETRY_ATTEMPTS) {
            try {
                attempts++;
                log.info("Attempting to execute workflow (attempt {}/{}): taskId={}", 
                        attempts, MAX_RETRY_ATTEMPTS, context.getTaskId());
                
                return workflowExecuteManager.asyncExecute(config, context);
                
            } catch (Exception e) {
                lastException = e;
                log.warn("Workflow execution attempt {} failed: {}", attempts, e.getMessage());
                
                if (attempts < MAX_RETRY_ATTEMPTS) {
                    try {
                        Thread.sleep(RETRY_DELAY_MS);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
        
        log.error("All workflow execution attempts failed after {} retries", MAX_RETRY_ATTEMPTS, lastException);
        throw new RuntimeException("Workflow execution failed after " + MAX_RETRY_ATTEMPTS + " attempts", lastException);
    }
}
```

## 示例5: 性能监控

```java
@Component
public class WorkflowPerformanceMonitor {

    private final Map<String, WorkflowMetrics> metricsMap = new ConcurrentHashMap<>();
    
    @EventListener
    public void handleWorkflowStart(WorkflowStartEvent event) {
        WorkflowMetrics metrics = new WorkflowMetrics();
        metrics.setTaskId(event.getTaskId());
        metrics.setStartTime(System.currentTimeMillis());
        metrics.setAppId(event.getAppId());
        metricsMap.put(event.getTaskId(), metrics);
        
        log.info("Workflow started: taskId={}, appId={}", event.getTaskId(), event.getAppId());
    }
    
    @EventListener
    public void handleWorkflowComplete(WorkflowCompleteEvent event) {
        WorkflowMetrics metrics = metricsMap.get(event.getTaskId());
        if (metrics != null) {
            metrics.setEndTime(System.currentTimeMillis());
            metrics.setDuration(metrics.getEndTime() - metrics.getStartTime());
            metrics.setStatus(event.getStatus());
            metrics.setNodeCount(event.getNodeCount());
            
            log.info("Workflow completed: taskId={}, duration={}ms, status={}", 
                    event.getTaskId(), metrics.getDuration(), event.getStatus());
            
            // 记录性能指标
            recordPerformanceMetrics(metrics);
            
            // 清理指标数据
            metricsMap.remove(event.getTaskId());
        }
    }
    
    private void recordPerformanceMetrics(WorkflowMetrics metrics) {
        // 这里可以集成监控系统，如 Prometheus、Micrometer 等
        log.info("Performance metrics: taskId={}, duration={}ms, nodeCount={}, status={}", 
                metrics.getTaskId(), metrics.getDuration(), metrics.getNodeCount(), metrics.getStatus());
    }
    
    @Data
    public static class WorkflowMetrics {
        private String taskId;
        private String appId;
        private long startTime;
        private long endTime;
        private long duration;
        private String status;
        private int nodeCount;
    }
}
```

## 示例6: 配置类

```java
@Configuration
@ConfigurationProperties(prefix = "workflow.async")
@Data
public class AsyncWorkflowConfig {

    /**
     * 是否启用异步执行
     */
    private boolean enabled = true;
    
    /**
     * 最大并发任务数
     */
    private int maxConcurrentTasks = 100;
    
    /**
     * 任务超时时间（秒）
     */
    private int taskTimeoutSeconds = 300;
    
    /**
     * 消息重试次数
     */
    private int messageRetryCount = 3;
    
    /**
     * 消息发送超时时间（毫秒）
     */
    private int messageSendTimeoutMs = 5000;
    
    /**
     * 消费者线程数
     */
    private int consumerThreadCount = 20;
}
```

## 示例7: 使用配置的异步执行

```java
@Service
public class ConfigurableWorkflowService {

    @Autowired
    private WorkflowExecuteManager workflowExecuteManager;
    
    @Autowired
    private AsyncWorkflowConfig asyncConfig;

    public String executeWorkflow(WorkflowConfig config, WorkflowContext context) {
        // 检查是否启用异步执行
        if (!asyncConfig.isEnabled()) {
            // 回退到同步执行
            return workflowExecuteManager.execute(config, context);
        }
        
        // 检查并发任务数限制
        if (getCurrentTaskCount() >= asyncConfig.getMaxConcurrentTasks()) {
            log.warn("Max concurrent tasks reached, falling back to sync execution");
            return workflowExecuteManager.execute(config, context);
        }
        
        // 设置任务超时
        context.setTimeout(asyncConfig.getTaskTimeoutSeconds() * 1000L);
        
        // 异步执行
        return workflowExecuteManager.asyncExecute(config, context);
    }
    
    private int getCurrentTaskCount() {
        // 这里可以实现获取当前执行任务数的逻辑
        // 可以通过 Redis 或其他方式统计
        return 0; // 示例实现
    }
}
```

## 总结

这些示例展示了异步工作流执行功能的各种使用场景：

1. **基本异步执行**: 简单的异步工作流启动
2. **带监控的异步执行**: 实时监控任务执行状态
3. **批量异步执行**: 同时执行多个工作流
4. **错误处理和重试**: 提高系统可靠性
5. **性能监控**: 跟踪和分析执行性能
6. **配置管理**: 灵活控制异步执行行为
7. **可配置执行**: 根据配置选择执行方式

通过这些示例，开发者可以根据具体需求选择合适的实现方式，充分利用异步执行的优势。 